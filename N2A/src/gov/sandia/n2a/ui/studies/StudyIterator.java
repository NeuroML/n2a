/*
Copyright 2020-2021 National Technology & Engineering Solutions of Sandia, LLC (NTESS).
Under the terms of Contract DE-NA0003525 with NTESS,
the U.S. Government retains certain rights in this software.
*/

package gov.sandia.n2a.ui.studies;

import gov.sandia.n2a.db.MNode;

/**
    A hierarchical iterator for enumerating combinations of parameters.
    When chained with other iterators, the outermost iterator varies the fastest.
    An empty iterator is not allowed. Every iterator must offer a sequence at least 1 item long.
**/
public abstract class StudyIterator
{
    protected StudyIterator inner;   // sub-iterator. If null, then this is the last iterator in the chain.
    protected String[]      keyPath; // full set of keys that address the location of the variable
    // concrete classes will also include information on the specific values to iterate over

    /**
        Immediately after construction, this iterator points before the beginning of the sequence.
        A call to next() must come before a call to assign().
        When composing with an inner iterator, call restart() or next() on the inner iterator to properly prepare it.
    **/
    public StudyIterator (String[] keys)
    {
        this.keyPath = keys;
    }

    public abstract int     count ();             // Returns the total number of samples that will be generated by one complete sequence.
    public abstract void    restart ();           // Moves this iterator to start of sequence, without regard to inner iterators. An immediate call to assign() will hand out the first item. This is similar to next() but unlike the initial state after construction.
    public abstract boolean step ();              // Moves this iterator to next item in sequence, without regard to inner iterator. Returns false if no more items are available.
    public abstract void    assign (MNode model); // Applies current value to model. Also calls inner.assign().
    public abstract void    save (MNode study);   // Store the state of this iterator. Also calls inner.save().
    public abstract void    load (MNode study);   // Retrieve the saved state of this iterator so it can resume exactly where it left off. Also calls inner.load().

    public boolean next ()
    {
        if (step ()) return true;
        // Past end of sequence. We can only restart if there is an inner iterator that has another item to offer.
        if (inner != null  &&  inner.next ())
        {
            restart ();
            return true;
        }
        return false;
    }

    // Indicates that the caller should wait until all previously-generated jobs finish before calling next again.
    public boolean barrier ()
    {
        return false;
    }

    /**
        Utility function to locate the node within the study tree the contains the parameters for this iterator.
        This can be used to further save/load state.
    **/
    public MNode node (MNode study)
    {
        return study.child ("variables").child (keyPath);  // This node will always exist, since it was used to create the iterator.
    }
}
